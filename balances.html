<head>
  <meta charset="UTF-8" />

  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />

  <meta
    name="apple-mobile-web-app-status-bar-style"
    content="black-translucent"
  />

  <title>Balances</title>

  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-180.png">

  <!-- üî• Decide theme BEFORE styles load -->
  <style>
    html {
      background: var(--bg, #0b0f14);
    }
  </style>

  <script>
    const theme = localStorage.getItem("theme") || "dark";
    document.documentElement.setAttribute("data-theme", theme);
  </script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  >

  <!-- Styles -->
  <link rel="stylesheet" href="styles-light.css?v=2026-01-24">
  <link rel="stylesheet" href="styles-dark.css?v=2026-01-24">
</head>


  <body class="page balance-page">



  <!-- <div id="appLoader" class="app-loader">
    <div class="ios-spinner"></div>
  </div> -->


  <button id="themeToggle" class="theme-toggle">üåô</button>

  <div class="app">

<div class="header-row">
  <div class="expense-header">Dashboard</div>

  <a
    href="https://docs.google.com/spreadsheets/d/1btzhbKqJhdoWcHs6G3Fsm3fkS22N9EW1QGImdqtjnEU/edit?usp=sharing"
    target="_blank"
    class="icon-btn"
    aria-label="Open Google Sheets"
  >
    <img src="svgs/google-sheets.svg" alt="">
  </a>
</div>

<div id="lastUpdated" class="last-updated">
  Updating‚Ä¶
</div>




    <!-- BALANCE CARD -->
    <!-- BALANCE CARD WRAPPER -->
    <div class="balance-card-wrapper">

      <!-- SOLID SKELETON (visible by default) -->
      <div id="balanceSkeleton" class="balance-card skeleton-block"></div>

      <!-- REAL CARD -->
      <div id="balanceCard" class="balance-card hidden">
        <div class="balance-content">
          <div class="balance-label">Current Balance</div>
          <div id="totalBalance" class="balance-amount">‚Ç±0.00</div>
        </div>

        <button id="eyeToggle" class="eye-btn">
          <img
            id="eyeIcon"
            src="svgs/eye-closed-svgrepo-com.svg"
            alt="Toggle visibility"
          >
        </button>
      </div>

    </div>




    <!-- ACCOUNTS -->
    <div class="section-title">Accounts</div>

    <div id="accounts" class="accounts loading">
      <div class="account-skeleton"></div>
      <div class="account-skeleton"></div>
      <div class="account-skeleton"></div>
    </div>


    <!-- SUMMARY -->
    <div class="expenses-header">
      <div class="section-title">Summary</div>

      <select id="monthSelect" class="month-select inline"></select>
    </div>

    <!-- SUMMARY SKELETON (visible by default) -->
<div id="summarySkeleton" class="summary-skeleton">
  <div class="donut-skeleton">
  <svg viewBox="0 0 200 200" class="donut-svg">
    <circle
      cx="100"
      cy="100"
      r="80"
      class="donut-skeleton-ring"
    />
  </svg>
</div>


  <div class="skeleton skeleton-line"></div>
  <div class="skeleton skeleton-line"></div>
  <div class="skeleton skeleton-line"></div>
  <div class="skeleton skeleton-line"></div>
</div>

<!-- SUMMARY CONTENT (hidden until data is ready) -->
<div id="summaryContent" class="hidden summary-loading">

  <div class="expense-donut">
    <svg viewBox="0 0 200 200" class="donut-svg">
      <defs>
        <!-- Donut ring clip -->
        <mask id="donutRingMask">
          <!-- hide everything -->
          <rect width="100%" height="100%" fill="black"/>

          <!-- outer edge of stroke -->
          <circle cx="100" cy="100" r="87" fill="white"/>

          <!-- inner edge of stroke -->
          <circle cx="100" cy="100" r="73" fill="black"/>
        </mask>



        <!-- White highlight gradient -->
        <radialGradient
          id="donutGlowLight"
          gradientUnits="userSpaceOnUse"
          cx="145"
          cy="155"
          r="130"
        >
          <stop offset="0%" stop-color="white" stop-opacity="0.6" />
          <stop offset="40%" stop-color="white" stop-opacity="0.35" />
          <stop offset="65%" stop-color="white" stop-opacity="0.15" />
          <stop offset="100%" stop-color="white" stop-opacity="0" />
        </radialGradient>

        <!-- Dark mode depth -->
        <radialGradient
          id="donutGlowDark"
          gradientUnits="userSpaceOnUse"
          cx="145"
          cy="155"
          r="130"
        >
          <stop offset="0%" stop-color="black" stop-opacity="0.6" />
          <stop offset="40%" stop-color="black" stop-opacity="0.35" />
          <stop offset="65%" stop-color="black" stop-opacity="0.18" />
          <stop offset="100%" stop-color="black" stop-opacity="0" />
        </radialGradient>

      </defs>

      <!-- background ring -->
      <circle cx="100" cy="100" r="80" class="donut-bg" />

      <!-- segments -->
      <g id="donutSegments"></g>

      <!-- glow overlay (light mode default) -->
    <!-- light mode glow -->
    <circle
      cx="100"
      cy="100"
      r="90"
      fill="url(#donutGlowLight)"
      mask="url(#donutRingMask)"
      pointer-events="none"
      class="donut-glow glow-light"
    />

    <!-- dark mode glow -->
    <circle
      cx="100"
      cy="100"
      r="90"
      fill="url(#donutGlowDark)"
      mask="url(#donutRingMask)"
      pointer-events="none"
      class="donut-glow glow-dark"
    />

    </svg>

    <div class="donut-center">
      <div class="donut-pill">
        <span id="donutMonth">January 2026</span>
      </div>

      <div class="donut-amount">
        <span class="currency"></span>
        <span id="donutAmount">0.00</span>
      </div>

      <div class="donut-label">Total spent</div>
    </div>

  </div>

  <div id="noDataState" class="no-data hidden">
    <img src="svgs/empty-state.svg" alt="" />
    <div class="no-data-text">No data available</div>
  </div>

  <div id="categoryTotals" class="category-totals"></div>

</div>



<section class="card recent-expenses">
  <div class="recent-header">
    <div class="section-title">Recent Transactions</div>

    <button
      id="syncBtn"
      class="sync-btn"
      aria-label="Sync"
      title="Sync"
    >
      ‚ü≥
    </button>
  </div>


  <ul id="recentExpenses" class="expenses-list">
    <li class="recent-skeleton"></li>
    <li class="recent-skeleton"></li>
    <li class="recent-skeleton"></li>
    <li class="recent-skeleton"></li>
  </ul>

</section>

<button id="logoutBtnBottom" class="logout-btn">
  Log out
</button>





  <!-- NAVBAR -->
  <nav class="bottom-nav">
    <a class="nav-item active">
      <img src="svgs/home-svgrepo-com-filled.svg">
      <span>Home</span>
    </a>

    <a href="index.html" class="nav-item">
      <img src="svgs/minus-square-svgrepo-com.svg">
      <span>Expense</span>
    </a>

    <a href="inflow.html" class="nav-item">
      <img src="svgs/add-square-svgrepo-com.svg">
      <span>Inflow</span>
    </a>

    <a href="transfer.html" class="nav-item">
      <img src="svgs/refresh-square-svgrepo-com.svg">
      <span>Transfer</span>
    </a>
  </nav>

<script>

const CATEGORY_EMOJI_MAP = {
  Food: "üçî",
  Transpo: "üöå",
  Bills: "üí°",
  Personal: "üë§",
  Shopping: "üõç",
  Entertainment: "üé¨",
  Others: "üì¶"
};



let didSyncFromNetwork = false;


const dashboardLoadState = {
balances: false,
categories: false,
recent: false
};

let lastRenderedCount = 0;
let isCollapsingRecent = false;


let allRecentTransactions = [];
let visibleRecentCount = 5;
const RECENT_STEP = 5;



const toggle = document.querySelector(".theme-toggle");

let hideTimeout;
let scrollTimer;

function showToggle() {
  if (!toggle) return;

  toggle.classList.add("visible");
  clearTimeout(hideTimeout);

  hideTimeout = setTimeout(() => {
    toggle.classList.remove("visible");
  }, 2000);
}

// desktop
document.addEventListener("mousemove", (e) => {
  if (e.clientY > window.innerHeight - 200) {
    showToggle();
  }
});

// mobile + desktop scroll
window.addEventListener("scroll", () => {
  showToggle();

  clearTimeout(scrollTimer);
  scrollTimer = setTimeout(() => {
    toggle.classList.remove("visible");
  }, 1500);
}, { passive: true });


  let appInitialized = false;
  let activeCategory = null;

    
  // const appLoader = document.getElementById("appLoader");

  // // üîÅ first-load logic
  // const isFirstLoad = !localStorage.getItem("hasLoadedBefore");

  // if (isFirstLoad) {
  //   appLoader.classList.remove("hidden"); // show loader
  //   localStorage.setItem("hasLoadedBefore", "1");
  // } else {
  //   appLoader.classList.add("hidden"); // skip loader entirely
  // }

  // function hideLoader() {
  //   if (!appLoader) return;

  //   appLoader.classList.add("hidden");

  //   setTimeout(() => {
  //     if (appLoader.parentNode) {
  //       appLoader.remove();
  //     }
  //   }, 350);
  // }


  function fetchWithTimeout(url, options = {}, timeout = 8000) {
    return Promise.race([
      fetch(url, options),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Request timeout")), timeout)
      )
    ]);
  }

  function updateDonutMonthLabel(year, month) {
  const d = new Date(year, month - 1, 1);
  const label = d.toLocaleString("default", {
    month: "long",
    year: "numeric"
  });

  document.getElementById("donutMonth").textContent = label;
}



  function showNoDataState() {
    document.getElementById("noDataState")?.classList.remove("hidden");
    document.querySelector(".expense-donut")?.classList.add("hidden");
    document.getElementById("categoryTotals").classList.add("hidden");
  }

  function hideNoDataState() {
    document.getElementById("noDataState")?.classList.add("hidden");
    document.querySelector(".expense-donut")?.classList.remove("hidden");
    document.getElementById("categoryTotals").classList.remove("hidden");
  }

  function showSummaryContent() {
    const skel = document.getElementById("summarySkeleton");
    if (skel) skel.remove();

    const summary = document.getElementById("summaryContent");
    summary?.classList.remove("hidden");
    summary?.classList.remove("summary-loading");
  }

  function setLastUpdatedNow() {
    const el = document.getElementById("lastUpdated");
    if (!el) return;

    const now = new Date();
    localStorage.setItem("lastUpdated", now.toISOString());

    el.textContent = "Updated just now";
  }

  function restoreLastUpdated() {
    const el = document.getElementById("lastUpdated");
    if (!el) return;

    const saved = localStorage.getItem("lastUpdated");

    if (!saved) {
      el.textContent = "Updating‚Ä¶";
      return;
    }

    const diffMs = Date.now() - new Date(saved).getTime();
    const mins = Math.floor(diffMs / 60000);
    const hours = Math.floor(mins / 60);

    let timeText =
      mins < 1 ? "just now" :
      mins === 1 ? "1 minute ago" :
      mins < 60 ? `${mins} minutes ago` :
      hours === 1 ? "1 hour ago" :
      `${hours} hours ago`;

    if (!navigator.onLine) {
      el.textContent = `Offline ¬∑ last updated ${timeText}`;
    } else {
      el.textContent = `Updated ${timeText}`;
    }
  }

  // üîÅ React to connectivity changes
window.addEventListener("online", restoreLastUpdated);
window.addEventListener("offline", restoreLastUpdated);



function maybeRevealLoaders() {
  const ready =
    dashboardLoadState.balances &&
    dashboardLoadState.categories &&
    dashboardLoadState.recent;

  if (!ready) return;

  /* üü¶ BALANCE */
  document.getElementById("balanceSkeleton")?.remove();
  document.getElementById("balanceCard")?.classList.remove("hidden");

  /* üü¶ ACCOUNTS */
  const accounts = document.getElementById("accounts");
  accounts.classList.remove("loading");
  accounts
    .querySelectorAll(".account-skeleton")
    .forEach(el => el.remove());

  /* üü¶ SUMMARY (DONUT + CATEGORY) */
  document.getElementById("summarySkeleton")?.remove();
  document.getElementById("summaryContent")?.classList.remove("hidden");

  /* üü¶ RECENT */
  document
    .querySelectorAll(".recent-skeleton")
    .forEach(el => el.remove());

  /* üü¶ DONUT ANIMATION */
  requestAnimationFrame(() => {
    revealDonut();
  });

  /* üü¶ LAST UPDATED */
  if (didSyncFromNetwork) {
    setLastUpdatedNow();
    didSyncFromNetwork = false;
  }
}



  let lastCategoryData = [];



  /* ================= VISIBILITY / MASKING ================= */

  if (!localStorage.getItem("balancesVisible")) {
    localStorage.setItem("balancesVisible", "false");
  }

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      balancesLockedVisible = false;
      balancesPeekVisible = false;
      updateBalanceVisibility();
    }
  });


  const eyeToggle = document.getElementById("eyeToggle");
  const eyeIcon = document.getElementById("eyeIcon");

  let balancesLockedVisible =
    localStorage.getItem("balancesVisible") === "true";

  let balancesPeekVisible = false;

  let realTotal = 0;
  let accountAmountEls = [];
  let categoryAmountEls = [];

  function maskAmount(value) {
    const formatted = value.toLocaleString(undefined, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });

    return "‚Ç±" + "*".repeat(formatted.length);
  }

  function updateBalanceVisibility() {
    const totalEl = document.getElementById("totalBalance");
    const isVisible = balancesLockedVisible || balancesPeekVisible;

    // total balance
    totalEl.textContent = isVisible
      ? "‚Ç±" + realTotal.toLocaleString(undefined, { minimumFractionDigits: 2 })
      : maskAmount(realTotal);
    totalEl.classList.add("ready"); // Show after masking

    // all registered money elements
    accountAmountEls.forEach(el => {
      const val = Number(el.dataset.real);
      el.textContent = isVisible
        ? "‚Ç±" + val.toLocaleString(undefined, { minimumFractionDigits: 2 })
        : maskAmount(val);
      el.classList.add("ready"); // Show after masking
    });

    categoryAmountEls.forEach(el => {
    const val = Number(el.dataset.real);
    el.textContent = isVisible
      ? "‚Ç±" + val.toLocaleString(undefined, { minimumFractionDigits: 2 })
      : maskAmount(val);
    el.classList.add("ready");
  });

    // donut center
    const donutAmountEl = document.getElementById("donutAmount");
    if (donutAmountEl?.dataset.real) {
      const val = Number(donutAmountEl.dataset.real);
      donutAmountEl.textContent = isVisible
        ? "‚Ç±" + val.toLocaleString(undefined, { minimumFractionDigits: 2 })
        : maskAmount(val);
      donutAmountEl.classList.add("ready"); // Show after masking
    }

    eyeIcon.src = balancesLockedVisible
      ? "svgs/eye-svgrepo-com.svg"
      : "svgs/eye-closed-svgrepo-com.svg";

    localStorage.setItem("balancesVisible", balancesLockedVisible);


  }

  eyeToggle.onclick = () => {
    balancesLockedVisible = !balancesLockedVisible;
    balancesPeekVisible = false; // clear any peek
    updateBalanceVisibility();
  };


  const totalBalanceEl = document.getElementById("totalBalance");

  let holdTimer = null;

  // TOUCH (iOS)
  totalBalanceEl.addEventListener("touchstart", () => {
    if (balancesLockedVisible) return; // üîí important

    holdTimer = setTimeout(() => {
      balancesPeekVisible = true;
      updateBalanceVisibility();
    }, 120);
  });

  totalBalanceEl.addEventListener("touchend", () => {
    clearTimeout(holdTimer);

    if (balancesLockedVisible) return;

    balancesPeekVisible = false;
    updateBalanceVisibility();
  });

  totalBalanceEl.addEventListener("touchcancel", () => {
    clearTimeout(holdTimer);
    balancesPeekVisible = false;
    updateBalanceVisibility();
  });

  // MOUSE (desktop)
  totalBalanceEl.addEventListener("mousedown", () => {
    if (balancesLockedVisible) return;

    balancesPeekVisible = true;
    updateBalanceVisibility();
  });

  totalBalanceEl.addEventListener("mouseup", () => {
    balancesPeekVisible = false;
    updateBalanceVisibility();
  });

  totalBalanceEl.addEventListener("mouseleave", () => {
    balancesPeekVisible = false;
    updateBalanceVisibility();
  });


  const donutWrapper = document.querySelector(".expense-donut");
  donutWrapper.classList.add("donut-collapsed");


  /* ================= DONUT HIGHLIGHT ================= */
function highlightDonut(category) {
  document.querySelectorAll("#donutSegments circle").forEach(c => {
    c.classList.add("dimmed");
    if (c.dataset.category === category) {
      c.classList.remove("dimmed");
    }
  });
}

function resetDonutHighlight() {
  document.querySelectorAll("#donutSegments circle").forEach(c => {
    c.classList.remove("dimmed");
  });
}



  /* ================= LOAD BALANCES ================= */
  const scriptURL =
  "https://script.google.com/macros/s/AKfycbx0j7hBNOI9P_zceaZeLrkypGOXP5s7Emk0GqOfUiNns1K6kEq0Xy2DJR00BVuEejw/exec";

  /* ================= ACCOUNT SELECTION MODEL ================= */

const SELECTED_ACCOUNTS_KEY = "selected_accounts";

function initSelectedAccounts(accounts) {
  const stored = localStorage.getItem(SELECTED_ACCOUNTS_KEY);
  if (stored) return JSON.parse(stored);

  // Default: exclude BPI (savings)
  const selected = accounts
    .filter(a => a.account.toLowerCase() !== "bpi")
    .map(a => a.account);

  localStorage.setItem(
    SELECTED_ACCOUNTS_KEY,
    JSON.stringify(selected)
  );

  return selected;
}

function toggleAccountSelection(accountName) {
  const selected = JSON.parse(
    localStorage.getItem(SELECTED_ACCOUNTS_KEY) || "[]"
  );

  const idx = selected.indexOf(accountName);
  if (idx >= 0) selected.splice(idx, 1);
  else selected.push(accountName);

  localStorage.setItem(
    SELECTED_ACCOUNTS_KEY,
    JSON.stringify(selected)
  );

  // Re-render balances using cached dashboard data
  const cached = sessionStorage.getItem("dashboard_balances");
  if (cached) {
    renderBalances(JSON.parse(cached));
  }
}


async function loadBalances(force = false) {
  let cachedBalances = null;

  // 1Ô∏è‚É£ Read cache, but DO NOT render yet
  if (!force) {
    const cached = sessionStorage.getItem("dashboard_balances");
    if (cached) {
      cachedBalances = JSON.parse(cached);
    }
  }

  try {
    // 2Ô∏è‚É£ Try network
    const res = await fetchWithTimeout(scriptURL);
    const json = await res.json();

    didSyncFromNetwork = true;

    sessionStorage.setItem(
      "dashboard_balances",
      JSON.stringify(json.data)
    );

    // Prefer fresh data
    cachedBalances = json.data;

  } catch (e) {
    console.warn("Using cached balances (offline)");
  } finally {
    // 3Ô∏è‚É£ Render ONCE, here
    if (cachedBalances) {
      renderBalances(cachedBalances);
    }

    // 4Ô∏è‚É£ Mark balances ready
    dashboardLoadState.balances = true;
    maybeRevealLoaders();
  }
}


let balancesRenderedOnce = false;

function renderBalances(data) {
  const container = document.getElementById("accounts");

  container.innerHTML = "";

  accountAmountEls = [];
  realTotal = 0;

  // üîπ init / load selected accounts
  const selectedAccounts = initSelectedAccounts(data);

  data.forEach(b => {
    const amount = Number(String(b.balance).replace(/,/g, ""));
    const name = b.account;
    const key = name.toLowerCase();

    let cls = "maribank";
    if (key.includes("gcash")) cls = "gcash";
    else if (key.includes("cash")) cls = "cash";
    else if (key.includes("maya")) cls = "maya";
    else if (key.includes("bpi")) cls = "bpi";

    const card = document.createElement("div");
    card.className = `account-card ${cls}`;

    const nameEl = document.createElement("div");
    nameEl.className = "account-name";
    nameEl.textContent = name;

    const amountEl = document.createElement("div");
    amountEl.className = "account-amount";
    amountEl.dataset.real = amount;

    const isSelected = selectedAccounts.includes(name);
    card.classList.toggle("selected", isSelected);
    card.classList.toggle("deselected", !isSelected);

    if (isSelected) {
      realTotal += Math.round(amount * 100) / 100;
    }

    card.onclick = () => toggleAccountSelection(name);

    card.appendChild(nameEl);
    card.appendChild(amountEl);
    container.appendChild(card);

    accountAmountEls.push(amountEl);
  });


  updateBalanceVisibility();
  dashboardLoadState.balances = true;
  maybeRevealLoaders();

}



/* ================= RECENT EXPENSES ================= */

function getRecentTxUrl() {
  return `${scriptURL}?action=recentTransactions&_=${Date.now()}`;
}

const RECENT_TX_CACHE_KEY = "recent_transactions_cache";
const RECENT_TX_CACHE_TTL = 60 * 1000;


function cacheRecentTransactions(data) {
  localStorage.setItem(
    RECENT_TX_CACHE_KEY,
    JSON.stringify({ ts: Date.now(), data })
  );
}

function getCachedRecentTransactions() {
  const raw = localStorage.getItem(RECENT_TX_CACHE_KEY);
  if (!raw) return null;

  const { ts, data } = JSON.parse(raw);
  if (Date.now() - ts > RECENT_TX_CACHE_TTL) return null;

  return data;
}

function paymentToClass(value) {
  if (!value) return "";
  const v = value.toLowerCase();

  if (v.includes("gcash")) return "gcash";
  if (v.includes("maya")) return "maya";
  if (v.includes("mari")) return "maribank";
  if (v.includes("bpi")) return "bpi";
  if (v.includes("cash")) return "cash";

  return "";
}

function renderRecentTransactions({ silent = false } = {}) {
  const list = document.getElementById("recentExpenses");

  list.innerHTML = "";
  list.classList.remove("skeleton");

  const items = allRecentTransactions.slice(0, visibleRecentCount);
  const newlyAddedStartIndex = lastRenderedCount;

  if (!items.length) {
    list.innerHTML = `
      <li class="account-card recent-card">
        <div class="recent-desc">No recent transactions</div>
      </li>
    `;

    if (!silent) {
      dashboardLoadState.recent = true;
      maybeRevealLoaders();
    }
    return;
  }

list.innerHTML = items.map((tx, index) => {
  const type = tx.type;

  let metaText = "";
  let paymentClass = "";

  if (type === "expense") {
    metaText = tx.payment;
    paymentClass = paymentToClass(tx.payment);
  }

  if (type === "inflow") {
    metaText = tx.account;
    paymentClass = paymentToClass(tx.account);
  }

  if (type === "transfer") {
    metaText = `${tx.from} ‚Üí ${tx.to}`;
    paymentClass = paymentToClass(tx.from);
  }

  let iconHTML = "";
  if (type === "expense") {
    const emoji = CATEGORY_EMOJI_MAP[tx.category] || "üí∏";
    iconHTML = `<span class="emoji-icon">${emoji}</span>`;
  } else {
    iconHTML = `<img src="svgs/${type}.svg" alt="${type}">`;
  }

  return `
    <li class="account-card recent-card ${type} ${paymentClass}
      ${index >= newlyAddedStartIndex ? "recent-animate" : ""}">
      <div class="recent-row">

        <div class="recent-icon">
          ${iconHTML}
        </div>

        <div class="recent-left">
          <div class="recent-desc" title="${tx.description}">
            ${tx.description}
          </div>

          <div class="recent-meta">
            <span class="recent-dot"></span>
            ${metaText}
          </div>
        </div>

        <div class="recent-right">
          <div class="recent-amount">
            ‚Ç±${Number(tx.amount).toLocaleString(undefined, {
              minimumFractionDigits: 2
            })}
          </div>
          <div class="recent-date">${tx.date}</div>
        </div>

      </div>
    </li>
  `;
}).join("");


  lastRenderedCount = visibleRecentCount;

  renderLoadMoreButton();

  // üîì ONLY unlock loaders when not silent
  if (!silent) {
    dashboardLoadState.recent = true;
    maybeRevealLoaders();
  }
}


function renderLoadMoreButton() {
  const list = document.getElementById("recentExpenses");

  const li = document.createElement("li");
  li.className = "load-more-row";

  const allVisible =
    visibleRecentCount >= allRecentTransactions.length;

  li.innerHTML = allVisible
    ? `<a href="#" class="load-more-link collapse">Show less</a>`
    : `<a href="#" class="load-more-link">Load more</a>`;

  li.querySelector("a").addEventListener("click", (e) => {
    e.preventDefault();

    if (visibleRecentCount >= allRecentTransactions.length) {
      // üîΩ collapse
      isCollapsingRecent = true;
      collapseRecentTransactions();
    } else {
      // üîº expand
      visibleRecentCount += RECENT_STEP;
      renderRecentTransactions();
    }
  });


  list.appendChild(li);
}

function collapseRecentTransactions() {
  const list = document.getElementById("recentExpenses");
  const items = Array.from(
    list.querySelectorAll(".recent-card")
  );

  // items beyond the first 5
  const toRemove = items.slice(RECENT_STEP);

  toRemove.forEach(el => {
    el.classList.add("recent-collapse");
  });

  // wait for animation to finish
  setTimeout(() => {
    visibleRecentCount = RECENT_STEP;
    lastRenderedCount = 0;
    isCollapsingRecent = false;
    renderRecentTransactions();
  }, 220);
}

function resetRecentSkeleton() {
  const list = document.getElementById("recentExpenses");
  if (!list) return;

  dashboardLoadState.recent = false;
  lastRenderedCount = 0;
  visibleRecentCount = RECENT_STEP;

  list.innerHTML = `
    <li class="recent-skeleton"></li>
    <li class="recent-skeleton"></li>
    <li class="recent-skeleton"></li>
    <li class="recent-skeleton"></li>
  `;
}



async function loadRecentTransactions(force = false) {
  const list = document.getElementById("recentExpenses");
  if (!list) return;

  // üö´ DO NOT silent-render if dashboard entry reset just happened
  if (!force && dashboardLoadState.recent === false) {
    // skip cache
  } else if (!force) {
    const cached = getCachedRecentTransactions();
    if (cached) {
      allRecentTransactions = cached;
      renderRecentTransactions({ silent: true });
      return;
    }
  }

  try {
    const res = await fetchWithTimeout(getRecentTxUrl(), {}, 15000);

    const json = await res.json();

    if (json.status !== "success") {
      throw new Error("API error");
    }

    // 2Ô∏è‚É£ Cache + store full list
    cacheRecentTransactions(json.data);

    allRecentTransactions = json.data || [];
    visibleRecentCount = RECENT_STEP;

    // 3Ô∏è‚É£ Normal render ‚Üí unlock loaders
    renderRecentTransactions();

    didSyncFromNetwork = true;

  } catch (err) {
    console.warn("[Recent TX] timeout, using cache or retry later");

    list.classList.remove("skeleton");
    list.innerHTML = `
      <li class="account-card recent-card">
        Failed to load
      </li>
    `;

    // Even on failure, mark as done so app can continue
    dashboardLoadState.recent = true;
    maybeRevealLoaders();
  }
}



  /* ================= DONUT ================= */
function updateDonutByCategory(data) {
  const group = document.getElementById("donutSegments");
  group.innerHTML = "";

  const total = data.reduce((s, d) => s + d.total, 0);
  document.getElementById("donutAmount").dataset.real = total;

  const RADIUS = 80;
  const CIRCUMFERENCE = 2 * Math.PI * RADIUS;

  let offset = 0;
  const GAP = 2; // visual gap in px

  data.forEach(item => {
    const fraction = total ? item.total / total : 0;
    const length = fraction * CIRCUMFERENCE;

    const visible = Math.max(length - GAP, 0);

    const circle = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );

    circle.setAttribute("cx", "100");
    circle.setAttribute("cy", "100");
    circle.setAttribute("r", RADIUS);
    circle.setAttribute("fill", "none");
    circle.setAttribute("stroke", getCategoryColor(item.category));
    circle.setAttribute("stroke-width", "14");
    circle.setAttribute("stroke-linecap", "butt"); // flat ends
    circle.dataset.category = item.category;

    circle.setAttribute(
      "stroke-dasharray",
      `${visible} ${CIRCUMFERENCE - visible}`
    );
    circle.setAttribute(
      "stroke-dashoffset",
      -offset
    );

    if (activeCategory === null) {
      // üî• nothing selected ‚Üí show everything normally
      circle.classList.remove("active");
      circle.classList.remove("dimmed");
    } else if (activeCategory === item.category) {
      // selected slice
      circle.classList.add("active");
      circle.classList.remove("dimmed");
    } else {
      // non-selected slices
      circle.classList.remove("active");
      circle.classList.add("dimmed");
    }


    offset += length;
    group.appendChild(circle);

    
  });

  updateBalanceVisibility();
}

  function revealDonut() {
    const donut = document.querySelector(".expense-donut");
    if (!donut) return;

    // next frame ensures browser has painted
    requestAnimationFrame(() => {
      donut.classList.remove("donut-collapsed");
    });
  }

  function collapseDonut() {
    const donut = document.querySelector(".expense-donut");
    if (!donut) return;

    donut.classList.add("donut-collapsed");
  }

  function getCategoryColor(category) {
  return `var(--cat-${category.toLowerCase()})`;
}


  /* ================= CATEGORY LIST ================= */
function renderCategoryList(data) {
  categoryAmountEls = [];  
  const container = document.getElementById("categoryTotals");
  container.innerHTML = "";

  data.forEach(item => {
    const row = document.createElement("div");
    row.className = "category-row";

    const color = getCategoryColor(item.category);

    const amountEl = document.createElement("span");
    amountEl.className = "cat-amount";
    amountEl.dataset.real = item.total;

    const nameEl = document.createElement("span");
    nameEl.className = "cat-name";
    nameEl.innerHTML = `
      <span class="cat-dot" style="background:${color}"></span>
      ${item.category}
    `;

    row.appendChild(nameEl);
    row.appendChild(amountEl);

    // üü¶ TEMP highlight on press
    // üü¶ temporary highlight
    // Highlight while pressing
    row.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      highlightDonut(item.category);
    });

    // Restore all slices on release
    row.addEventListener("pointerup", (e) => {
      e.preventDefault();
      resetDonutHighlight();
    });

    // Safety: if finger leaves
    row.addEventListener("pointerleave", () => {
      resetDonutHighlight();
    });



    container.appendChild(row);
    categoryAmountEls.push(amountEl);
  });

  updateBalanceVisibility();
}


/* ================= LOAD CATEGORY TOTALS ================= */
async function loadCategoryTotals(year, month) {
  const cacheKey = `dashboard_categories_${year}_${month}`;
  const cached = sessionStorage.getItem(cacheKey);

  // ‚úÖ USE CACHE FIRST
  if (cached) {
    const data = JSON.parse(cached);

    if (!data.length) {
      showNoDataState();

      dashboardLoadState.categories = true;
      maybeRevealLoaders();
      return;
    }

    hideNoDataState();

    const sorted = [...data].sort((a, b) => b.total - a.total);
    lastCategoryData = sorted;

    updateDonutByCategory(sorted);
    renderCategoryList(sorted);

    dashboardLoadState.categories = true;
    maybeRevealLoaders();
    return;
  }

  // ‚úÖ FETCH FROM SERVER
  const res = await fetchWithTimeout(
    `${scriptURL}?action=categoryTotals&year=${year}&month=${month}`
  );

  const json = await res.json();
  const data = json.data || [];

  didSyncFromNetwork = true;

  if (!data.length) {
    sessionStorage.setItem(cacheKey, JSON.stringify([]));
    showNoDataState();

    dashboardLoadState.categories = true;
    maybeRevealLoaders();
    return;
  }

  hideNoDataState();

  const sorted = [...data].sort((a, b) => b.total - a.total);
  lastCategoryData = sorted;

  sessionStorage.setItem(cacheKey, JSON.stringify(sorted));
  updateDonutByCategory(sorted);
  renderCategoryList(sorted);

  dashboardLoadState.categories = true;
  maybeRevealLoaders();
}


  /* ================= MONTH DROPDOWN ================= */
  const monthSelect = document.getElementById("monthSelect");

  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;

  // build last 12 months
  monthSelect.innerHTML = "";
  for (let i = 0; i < 12; i++) {
    const d = new Date(currentYear, currentMonth - 1 - i, 1);

    const value = `${d.getFullYear()}-${d.getMonth() + 1}`;
    const label = d.toLocaleString("default", {
      month: "long",
      year: "numeric"
    });

    const option = document.createElement("option");
    option.value = value;
    option.textContent = label;
    monthSelect.appendChild(option);
  }

  // default = current month
  monthSelect.value = `${currentYear}-${currentMonth}`;


  /* ================= APP RESUME (iOS / PWA) ================= */

  let resumeTimer = null;

  document.addEventListener("visibilitychange", () => {
    if (document.hidden || !appInitialized) return;

    clearTimeout(resumeTimer);
    resumeTimer = setTimeout(() => {
      loadBalances(true);
      loadCategoryTotals(currentYear, currentMonth);
      loadRecentTransactions(true);

      // acknowledge refresh
      localStorage.removeItem("data_dirty");
    }, 150);
  });



  // reload data on change
  monthSelect.addEventListener("change", async () => {
    const [year, month] = monthSelect.value.split("-");

    updateDonutMonthLabel(Number(year), Number(month));


    // clear old category UI to avoid stale flashes
    categoryAmountEls = [];
    document.getElementById("categoryTotals").innerHTML = "";

    collapseDonut(); // reset animation state

    await loadCategoryTotals(Number(year), Number(month));

    revealDonut(); // animate new data
  });

  const pageEl = document.querySelector(".page");

  function showApp() {
    pageEl.classList.add("page-ready");
  }

  async function initApp() {
    try {
      restoreLastUpdated();

      updateBalanceVisibility();

      // üî• show UI immediately
      document.body.classList.add("page-ready");

      // üî• RESET RECENT UI STATE
      resetRecentSkeleton();

      // load cached first
      loadBalances();
      loadCategoryTotals(currentYear, currentMonth);
      loadRecentTransactions();

      // then refresh in background
      Promise.allSettled([
        loadBalances(true),
        loadCategoryTotals(currentYear, currentMonth),
        loadRecentTransactions(true)
      ]);

    } catch (err) {
      console.error("Init error:", err);
    } finally {
      appInitialized = true;
      updateDonutMonthLabel(currentYear, currentMonth);
    }
  }



  initApp();


/* ================= SIMPLE REFRESH SYNC ================= */

const syncBtn = document.getElementById("syncBtn");
let refreshing = false;

async function refreshRecentTransactions() {
  if (refreshing) return;
  refreshing = true;

  syncBtn.classList.add("syncing");
  syncBtn.disabled = true;

  try {
    resetRecentSkeleton();

    // üî• clear ALL dashboard caches
    localStorage.removeItem("recent_transactions_cache");
    sessionStorage.removeItem("dashboard_balances");

    Object.keys(sessionStorage)
      .filter(k => k.startsWith("dashboard_categories_"))
      .forEach(k => sessionStorage.removeItem(k));

    // üî• force reload everything
    await Promise.all([
      loadBalances(true),
      loadCategoryTotals(currentYear, currentMonth),
      loadRecentTransactions(true)
    ]);

  } finally {
    refreshing = false;
    syncBtn.classList.remove("syncing");
    syncBtn.disabled = false;
    setLastUpdatedNow();
  }
}

syncBtn.addEventListener("click", refreshRecentTransactions);



</script>

<script>
  const slider = document.querySelector('.accounts');
  let isDown = false;
  let startX;
  let scrollLeft;

  slider.addEventListener('mousedown', (e) => {
    isDown = true;
    slider.classList.add('dragging');
    startX = e.pageX - slider.offsetLeft;
    scrollLeft = slider.scrollLeft;
  });

  slider.addEventListener('mouseleave', () => {
    isDown = false;
  });

  slider.addEventListener('mouseup', () => {
    isDown = false;
  });

  slider.addEventListener('mousemove', (e) => {
    if (!isDown) return;
    e.preventDefault();
    const x = e.pageX - slider.offsetLeft;
    const walk = (x - startX) * 1.2; // scroll speed
    slider.scrollLeft = scrollLeft - walk;
  });
</script>


<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>

<script>
  firebase.initializeApp({
    apiKey: "AIzaSyBn2kufYDw1It3d-yuf351ApSv54w_57Gk",
    authDomain: "spendr-39376.firebaseapp.com",
    projectId: "spendr-39376"
  });

  const SHEETS_URL =
  "https://docs.google.com/spreadsheets/d/1btzhbKqJhdoWcHs6G3Fsm3fkS22N9EW1QGImdqtjnEU/edit?usp=sharing";

document.addEventListener("DOMContentLoaded", () => {
  const logoutBtn = document.getElementById("logoutBtnBottom");
  if (!logoutBtn) return;

  logoutBtn.onclick = async () => {
    try {
      await firebase.auth().signOut();
      window.location.replace("/login.html");
    } catch (err) {
      console.error("Logout failed:", err);
    }
  };
});


</script>



<script src="auth-guard.js"></script>


  <script src="theme-engine.js"></script>

  </body>
  </html>
